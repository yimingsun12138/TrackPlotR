#' Coverage track visualization in the specified genome region
#' 
#' @description
#' Generate coverage track plot in the specified genome region.
#' 
#' @param coverage_table Genome coverage table generated by `load_BigWig`.
#' @param region Genome region used to generate the coverage track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend downstream the region?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param y_lim The numerical y-axis limit for coverage track plot.
#' @param sample_order The sample order when generating the coverage track.
#' @param col_pal A custom palette used to override coloring for samples.
#' 
#' @return A ggplot object.
#' 
#' @export
coverage_vis_region <- function(coverage_table,
                                region,
                                up_extend = 0,
                                down_extend = 0,
                                style = c('style_1'),
                                y_lim = NULL,
                                sample_order = NULL,
                                col_pal = NULL){
  
  #check parameter
  if(base::class(coverage_table) != 'data.frame'){
    base::stop('coverage_table must be a data.frame object!')
  }
  
  if(!base::all(c('seqnames','start','end','score','Sample') %in% base::colnames(coverage_table))){
    base::stop('missing columns in coverage_table!')
  }
  
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
  if(GenomicRanges::start(region) < 0){
    GenomicRanges::start(region) <- 0
  }
  GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
  if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
    base::stop('Invalid genome region!')
  }
  
  #check style
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  #basic plot
  coverage_plot <- coverage_vis_basic(coverage_table = coverage_table,
                                      region = region,
                                      y_lim = y_lim,
                                      sample_order = sample_order,
                                      col_pal = col_pal)
  
  #style
  if(style == 'style_1'){
    coverage_plot <- coverage_plot
  }
  
  #return
  return(coverage_plot)
}

#' Coverage track visualization around specified gene region
#' 
#' @description
#' Generate coverage track plot around specified gene region.
#' 
#' @param coverage_table Genome coverage table generated by `load_BigWig`.
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information.
#' Ensembl GTF file is recommended. If you wish to use a GTF file from another source, ensure the file contains the following three columns: 
#' 1. "type" which stores the types of each gene element, including gene, transcript, exon, and CDS.
#' 2. "gene_id", storing the gene to which each element belongs, this cannot be NULL or NA.
#' 3. "transcript_id", storing the transcript to which each element belongs, for each gene element that is not a gene type, the value cannot be NULL or NA.
#' @param column_name Which column in gene_anno to be searched for the specified gene name?
#' @param gene The name of the specified gene.
#' @param up_extend How many base pairs to extend upstream the gene?
#' @param down_extend How many base pairs to extend downstream the gene?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param y_lim The numerical y-axis limit for coverage track plot.
#' @param sample_order The sample order when generating the coverage track.
#' @param col_pal A custom palette used to override coloring for samples.
#' 
#' @return A ggplot object.
#' 
#' @export
coverage_vis_gene <- function(coverage_table,
                              gene_anno,
                              column_name,
                              gene,
                              up_extend = 3000,
                              down_extend = 3000,
                              style = c('style_1'),
                              y_lim = NULL,
                              sample_order = NULL,
                              col_pal = NULL){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!base::all(c('type',column_name) %in% base::colnames(S4Vectors::mcols(gene_anno)))){
    base::stop(base::paste0('gene_anno must contain two columns: type and ',column_name,'!'))
  }
  
  #get gene region
  idx <- base::which((gene_anno$type == 'gene') & (S4Vectors::mcols(gene_anno)[,column_name] == gene))
  if(base::length(idx) == 0){
    base::stop(base::paste(gene,'not found in the annotation!',sep = ' '))
  }
  if(base::length(idx) > 1){
    base::stop('multiple gene regions detected in the annotation!')
  }
  
  region <- gene_anno[idx]
  if(base::as.character(GenomicRanges::strand(region)) == '-'){
    GenomicRanges::start(region) <- GenomicRanges::start(region) - down_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + up_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }else{
    GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }
  
  #plot
  coverage_plot <- coverage_vis_region(coverage_table = coverage_table,
                                       region = region,
                                       up_extend = 0,
                                       down_extend = 0,
                                       style = style,
                                       y_lim = y_lim,
                                       sample_order = sample_order,
                                       col_pal = col_pal)
  
  #return
  return(coverage_plot)
}

#' Feature track visualization in the specified genome region
#' 
#' @description
#' Generate feature track plot in the specified genome region.
#' 
#' @param features A list of bed file paths or a GRanges/GRangesList object which stores the coordinates of genome features.
#' @param region Genome region used to generate the feature track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend downstream the region?
#' @param collapse_features Whether collapse the feature track, default is FALSE.
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param col_pal A custom palette used to override coloring for features.
#' @param overlap_col Color for overlapped region of different features if collapse_features is set to TRUE.
#' @param segment_size The thickness (linewidth) of the feature segment.
#' 
#' @return A ggplot object.
#' 
#' @export
feature_vis_region <- function(features,
                               region,
                               up_extend = 0,
                               down_extend = 0,
                               collapse_features = FALSE,
                               style = c('style_1'),
                               col_pal = NULL,
                               overlap_col = 'darkgrey',
                               segment_size = 2){
  
  #check parameter
  if(base::grepl(pattern = 'GRanges',x = base::class(features),fixed = TRUE)){
    features <- features
  }else{
    features <- base::unlist(features)
    if(base::class(features) == 'character'){
      feature_name <- base::names(features)
      features <- base::do.call(what = GenomicRanges::GRangesList,args = base::lapply(X = features,FUN = rtracklayer::import.bed))
      base::names(features) <- feature_name
    }else{
      base::stop('features must be a list of bed file paths or a GRanges/GRangesList object!')
    }
  }
  
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
  if(GenomicRanges::start(region) < 0){
    GenomicRanges::start(region) <- 0
  }
  GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
  if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
    base::stop('Invalid genome region!')
  }
  
  #check style
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  #basic plot
  feature_plot <- feature_vis_basic(Ranges = features,
                                    region = region,
                                    collapse_range = collapse_features,
                                    col_pal = col_pal,
                                    overlap_col = overlap_col,
                                    segment_size = segment_size)
  
  #style
  if(style == 'style_1'){
    feature_plot <- feature_plot
  }
  
  #return
  return(feature_plot)
}

#' Feature track visualization around specified gene region
#' 
#' @description
#' Generate feature track plot around specified gene region.
#' 
#' @param features A list of bed file paths or a GRanges/GRangesList object which stores the coordinates of genome features.
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information.
#' Ensembl GTF file is recommended. If you wish to use a GTF file from another source, ensure the file contains the following three columns: 
#' 1. "type" which stores the types of each gene element, including gene, transcript, exon, and CDS.
#' 2. "gene_id", storing the gene to which each element belongs, this cannot be NULL or NA.
#' 3. "transcript_id", storing the transcript to which each element belongs, for each gene element that is not a gene type, the value cannot be NULL or NA.
#' @param column_name Which column in gene_anno to be searched for the specified gene name?
#' @param gene The name of the specified gene.
#' @param up_extend How many base pairs to extend upstream the gene?
#' @param down_extend How many base pairs to extend downstream the gene?
#' @param collapse_features Whether collapse the feature track, default is FALSE.
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param col_pal A custom palette used to override coloring for features.
#' @param overlap_col Color for overlapped region of different features if collapse_features is set to TRUE.
#' @param segment_size The thickness (linewidth) of the feature segment.
#' 
#' @return A ggplot object.
#' 
#' @export
feature_vis_gene <- function(features,
                             gene_anno,
                             column_name,
                             gene,
                             up_extend = 3000,
                             down_extend = 3000,
                             collapse_features = FALSE,
                             style = c('style_1'),
                             col_pal = NULL,
                             overlap_col = 'darkgrey',
                             segment_size = 2){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!base::all(c('type',column_name) %in% base::colnames(S4Vectors::mcols(gene_anno)))){
    base::stop(base::paste0('gene_anno must contain two columns: type and ',column_name,'!'))
  }
  
  #get gene region
  idx <- base::which((gene_anno$type == 'gene') & (S4Vectors::mcols(gene_anno)[,column_name] == gene))
  if(base::length(idx) == 0){
    base::stop(base::paste(gene,'not found in the annotation!',sep = ' '))
  }
  if(base::length(idx) > 1){
    base::stop('multiple gene regions detected in the annotation!')
  }
  
  region <- gene_anno[idx]
  if(base::as.character(GenomicRanges::strand(region)) == '-'){
    GenomicRanges::start(region) <- GenomicRanges::start(region) - down_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + up_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }else{
    GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }
  
  #plot
  feature_plot <- feature_vis_region(features = features,
                                     region = region,
                                     up_extend = 0,
                                     down_extend = 0,
                                     collapse_features = collapse_features,
                                     style = style,
                                     col_pal = col_pal,
                                     overlap_col = overlap_col,
                                     segment_size = segment_size)
  
  #return
  return(feature_plot)
}

#' Transcript track visualization in the specified genome region
#' 
#' @description
#' Generate transcript track plot in the specified genome region. 
#' This function is the user interface for the basic function `transcript_vis_basic`, 
#' and is specifically optimized for Ensembl GTF file.
#' 
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information.
#' Ensembl GTF file is recommended. If you wish to use a GTF file from another source, ensure the file contains the following three columns: 
#' 1. "type" which stores the types of each gene element, including gene, transcript, exon, and CDS.
#' 2. "gene_id", storing the gene to which each element belongs, this cannot be NULL or NA.
#' 3. "transcript_id", storing the transcript to which each element belongs, for each gene element that is not a gene type, the value cannot be NULL or NA.
#' @param region Genome region used to generate the transcript track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend downstream the region?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param arrow_break The gap between neighbor arrows equals to region width times arrow_break.
#' @param display_by Display by transcripts or display by genes?
#' @param display_mode Display mode provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param show_name Which column in gene_anno stores the transcript/gene names to be plotted? Set to NULL and no name will be shown.
#' @param ... Try `?TrackPlotR::transcript_vis_basic` for more parameter information.
#' 
#' @return A ggplot object.
#' 
#' @export
transcript_vis_region <- function(gene_anno,
                                  region,
                                  up_extend = 0,
                                  down_extend = 0,
                                  style = c('style_1'),
                                  arrow_break = 0.04,
                                  display_by = c('gene','transcript'),
                                  display_mode = c('squish','full','collapse'),
                                  show_name = NULL,
                                  ...){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!('type' %in% base::colnames(S4Vectors::mcols(gene_anno)))){
    base::stop('gene_anno must contain the column: type!')
  }
  
  if(base::sum(gene_anno$type == 'transcript') == 0){
    base::stop('no transcript found in gene_anno!')
  }
  idx <- base::which(gene_anno$type %in% c('transcript','exon','CDS'))
  gene_anno <- gene_anno[idx]
  
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  display_by <- display_by[1]
  if(!(display_by %in% c('gene','transcript'))){
    base::stop('invalid display_by!')
  }
  
  display_mode <- display_mode[1]
  if(!(display_mode %in% c('squish','full','collapse'))){
    base::stop('invalid display_mode!')
  }
  
  if(!base::is.null(show_name)){
    if(!(show_name %in% base::colnames(S4Vectors::mcols(gene_anno)))){
      base::stop(base::paste0('gene_anno must contain the column: ',show_name,'!'))
    }
  }
  
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
  if(GenomicRanges::start(region) < 0){
    GenomicRanges::start(region) <- 0
  }
  GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
  if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
    base::stop('Invalid genome region!')
  }
  
  #initialize gene_anno
  if(display_by == 'gene'){
    #check data
    if(!('gene_id' %in% base::colnames(S4Vectors::mcols(gene_anno)))){
      base::stop('gene_anno must contain the column: gene_id!')
    }
    if(!base::all(!base::is.na(gene_anno$gene_id))){
      base::stop('NA is not allowed in gene_anno column: gene_id!')
    }
    if(!base::all(!base::is.null(gene_anno$gene_id))){
      base::stop('NULL is not allowed in gene_anno column: gene_id!')
    }
    
    #modify
    gene_anno$unique_id <- base::as.character(gene_anno$gene_id)
    
  }else if(display_by == 'transcript'){
    #check data
    if(!('transcript_id' %in% base::colnames(S4Vectors::mcols(gene_anno)))){
      base::stop('gene_anno must contain the column: transcript_id!')
    }
    if(!base::all(!base::is.na(gene_anno$transcript_id))){
      base::stop('NA is not allowed in gene_anno column: transcript_id!')
    }
    if(!base::all(!base::is.null(gene_anno$transcript_id))){
      base::stop('NULL is not allowed in gene_anno column: transcript_id!')
    }
    
    #modify
    gene_anno$unique_id <- base::as.character(gene_anno$transcript_id)
    
  }else{
    base::stop('I can not believe this happened, LOL')
  }
  
  if(base::is.null(show_name)){
    gene_anno$unique_name <- NA
  }else{
    gene_anno$unique_name <- base::as.character(S4Vectors::mcols(gene_anno)[,show_name])
  }
  
  gene_anno$cluster <- 1
  
  #subset gene_anno
  raw_gene_anno <- gene_anno
  gene_anno <- IRanges::subsetByOverlaps(x = gene_anno,ranges = region,type = 'any',invert = FALSE,ignore.strand = TRUE)
  
  #set gene_anno cluster
  if(base::length(gene_anno) != 0){
    #generate transcripts that represent the gene region if display by gene
    if(display_by == 'gene'){
      gene_list <- base::unique(base::as.character(gene_anno$gene_id))
      gene_list <- base::do.call(what = base::c,args = base::lapply(X = gene_list,FUN = function(x){
        idx <- base::which(gene_anno$gene_id == x)
        temp_anno <- gene_anno[idx]
        
        chr <- base::unique(base::as.character(GenomicRanges::seqnames(temp_anno)))
        start_site <- base::as.character(base::min(GenomicRanges::start(temp_anno)))
        end_site <- base::as.character(base::max(GenomicRanges::end(temp_anno)))
        strand_sign <- base::unique(base::as.character(GenomicRanges::strand(temp_anno)))
        
        if(base::length(strand_sign) != 1){
          temp_gene_region <- methods::as(object = base::paste0(chr,':',start_site,'-',end_site,':*'),Class = 'GRanges')
        }else{
          temp_gene_region <- methods::as(object = base::paste0(chr,':',start_site,'-',end_site,':',strand_sign),Class = 'GRanges')
        }
        
        temp_gene_region$type <- 'transcript'
        temp_gene_region$unique_id <- x
        temp_name <- base::unique(base::as.character(temp_anno$unique_name))
        if(base::length(temp_name) != 1){
          temp_gene_region$unique_name <- NA
        }else{
          temp_gene_region$unique_name <- temp_name
        }
        
        return(temp_gene_region)
      }))
      
      #replace transcripts
      idx <- base::which(gene_anno$type != 'transcript')
      gene_anno <- c(gene_anno[idx],gene_list)
    }
    
    #group gene_anno
    if(display_mode == 'squish'){
      gene_anno <- group_transcripts(gene_anno = gene_anno,column_name = 'unique_id')
      gene_anno$cluster <- base::max(as.numeric(gene_anno$cluster)) - as.numeric(gene_anno$cluster) + 1
    }else if(display_mode == 'full'){
      gene_anno$cluster <- gene_anno$unique_id
    }else if(display_mode == 'collapse'){
      gene_anno$cluster <- 1
    }else{
      base::stop('I can not believe this happened, LOL')
    }
  }else{
    #use raw gene anno and nothing will be plotted
    gene_anno <- raw_gene_anno
  }
  
  #plot
  transcript_plot <- transcript_vis_basic(anno = gene_anno,
                                          region = region,
                                          arrow_break = arrow_break,
                                          show_name = 'unique_name',
                                          ...)
  
  #style
  if(style == 'style_1'){
    transcript_plot <- transcript_plot
  }
  
  #return
  return(transcript_plot)
}

#' Gene track visualization
#' 
#' @description
#' Generate specified gene track plot. 
#' This function is specifically optimized for visualizing specified genes using `TrackPlotR::transcript_vis_region`.
#' 
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information.
#' Ensembl GTF file is recommended. If you wish to use a GTF file from another source, ensure the file contains the following three columns: 
#' 1. "type" which stores the types of each gene element, including gene, transcript, exon, and CDS.
#' 2. "gene_id", storing the gene to which each element belongs, this cannot be NULL or NA.
#' 3. "transcript_id", storing the transcript to which each element belongs, for each gene element that is not a gene type, the value cannot be NULL or NA.
#' @param column_name Which column in gene_anno to be searched for the specified gene name?
#' @param gene The name of the specified gene.
#' @param up_extend How many base pairs to extend upstream the gene?
#' @param down_extend How many base pairs to extend downstream the gene?
#' @param show_only Only show the specified gene or show other genes overlapped with the track region as well.
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param arrow_break The gap between neighbor arrows equals to region width times arrow_break.
#' @param display_mode Display mode provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param ... Try `?TrackPlotR::transcript_vis_region` for more parameter information.
#' 
#' @return A ggplot object
#' 
#' @export
gene_track_vis <- function(gene_anno,
                           column_name,
                           gene,
                           up_extend = 3000,
                           down_extend = 3000,
                           show_only = TRUE,
                           style = c('style_1'),
                           arrow_break = 0.04,
                           display_mode = c('squish','full','collapse'),
                           ...){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!base::all(c('type',column_name) %in% base::colnames(S4Vectors::mcols(gene_anno)))){
    base::stop(base::paste0('gene_anno must contain two columns: type and ',column_name,'!'))
  }
  
  #get gene region
  idx <- base::which((gene_anno$type == 'gene') & (S4Vectors::mcols(gene_anno)[,column_name] == gene))
  if(base::length(idx) == 0){
    base::stop(base::paste(gene,'not found in the annotation!',sep = ' '))
  }
  if(base::length(idx) > 1){
    base::stop('multiple gene regions detected in the annotation!')
  }
  
  region <- gene_anno[idx]
  if(base::as.character(GenomicRanges::strand(region)) == '-'){
    GenomicRanges::start(region) <- GenomicRanges::start(region) - down_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + up_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }else{
    GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }
  
  #subset gene_anno
  if(show_only){
    idx <- base::which(S4Vectors::mcols(gene_anno)[,column_name] == gene)
    gene_anno <- gene_anno[idx]
  }
  
  #plot
  transcript_plot <- transcript_vis_region(gene_anno = gene_anno,
                                           region = region,
                                           up_extend = 0,
                                           down_extend = 0,
                                           style = style,
                                           arrow_break = arrow_break,
                                           display_by = 'gene',
                                           display_mode = display_mode,
                                           show_name = column_name,
                                           ...)
  
  #return
  return(transcript_plot)
}

#' Linkage track visualization in the specified genome region
#' 
#' @description
#' Generate linkage track plot in the specified genome region.
#' 
#' @param linkage A GRanges object with each range's start and end points representing two loci on the genome where a linkage exists, and the strand represents the direction of the linkage.
#' @param region Genome region used to generate the linkage track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend downstream the region?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param color_by Which column in the linkage stores the intensity of each linkage that is used to control the color? Set to NULL and each linkage will be the same color.
#' @param col_pal A custom palette used to override coloring for each linkage.
#' @param allow_truncated Whether to display linkages that are truncated due to exceeding the region.
#' @param curve_width Line width used to draw the linkage.
#' @param max_arrow_length Max line length used to draw the arrow.
#' 
#' @return A ggplot object.
#' 
#' @export
linkage_vis_region <- function(linkage,
                               region,
                               up_extend = 0,
                               down_extend = 0,
                               style = c('style_1'),
                               color_by = NULL,
                               col_pal = c('#E6E7E8','#3A97FF','#8816A7','#000000'),
                               allow_truncated = FALSE,
                               curve_width = 0.5,
                               max_arrow_length = 0.08){
  
  #check parameter
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
  if(GenomicRanges::start(region) < 0){
    GenomicRanges::start(region) <- 0
  }
  GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
  if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
    base::stop('Invalid genome region!')
  }
  
  #check style
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  #basic plot
  linkage_plot <- linkage_vis_basic(linkage = linkage,
                                    region = region,
                                    color_by = color_by,
                                    col_pal = col_pal,
                                    allow_truncated = allow_truncated,
                                    curve_width = curve_width,
                                    max_arrow_length = max_arrow_length)
  
  #style
  if(style == 'style_1'){
    linkage_plot <- linkage_plot
  }
  
  #return
  return(linkage_plot)
}

#' Linkage track visualization around specified gene region
#' 
#' @description
#' Generate linkage track plot around specified gene region.
#' 
#' @param linkage A GRanges object with each range's start and end points representing two loci on the genome where a linkage exists, and the strand represents the direction of the linkage.
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information.
#' Ensembl GTF file is recommended. If you wish to use a GTF file from another source, ensure the file contains the following three columns: 
#' 1. "type" which stores the types of each gene element, including gene, transcript, exon, and CDS.
#' 2. "gene_id", storing the gene to which each element belongs, this cannot be NULL or NA.
#' 3. "transcript_id", storing the transcript to which each element belongs, for each gene element that is not a gene type, the value cannot be NULL or NA.
#' @param column_name Which column in gene_anno to be searched for the specified gene name?
#' @param gene The name of the specified gene.
#' @param up_extend How many base pairs to extend upstream the gene?
#' @param down_extend How many base pairs to extend downstream the gene?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param color_by Which column in the linkage stores the intensity of each linkage that is used to control the color? Set to NULL and each linkage will be the same color.
#' @param col_pal A custom palette used to override coloring for each linkage.
#' @param allow_truncated Whether to display linkages that are truncated due to exceeding the region.
#' @param curve_width Line width used to draw the linkage.
#' @param max_arrow_length Max line length used to draw the arrow.
#' 
#' @return A ggplot object.
#' 
#' @export
linkage_vis_gene <- function(linkage,
                             gene_anno,
                             column_name,
                             gene,
                             up_extend = 3000,
                             down_extend = 3000,
                             style = c('style_1'),
                             color_by = NULL,
                             col_pal = c('#E6E7E8','#3A97FF','#8816A7','#000000'),
                             allow_truncated = FALSE,
                             curve_width = 0.5,
                             max_arrow_length = 0.08){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!base::all(c('type',column_name) %in% base::colnames(S4Vectors::mcols(gene_anno)))){
    base::stop(base::paste0('gene_anno must contain two columns: type and ',column_name,'!'))
  }
  
  #get gene region
  idx <- base::which((gene_anno$type == 'gene') & (S4Vectors::mcols(gene_anno)[,column_name] == gene))
  if(base::length(idx) == 0){
    base::stop(base::paste(gene,'not found in the annotation!',sep = ' '))
  }
  if(base::length(idx) > 1){
    base::stop('multiple gene regions detected in the annotation!')
  }
  
  region <- gene_anno[idx]
  if(base::as.character(GenomicRanges::strand(region)) == '-'){
    GenomicRanges::start(region) <- GenomicRanges::start(region) - down_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + up_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }else{
    GenomicRanges::start(region) <- GenomicRanges::start(region) - up_extend
    if(GenomicRanges::start(region) < 0){
      GenomicRanges::start(region) <- 0
    }
    GenomicRanges::end(region) <- GenomicRanges::end(region) + down_extend
    if(GenomicRanges::end(region) <= GenomicRanges::start(region)){
      base::stop('Invalid genome region!')
    }
  }
  
  #plot
  linkage_plot <- linkage_vis_region(linkage = linkage,
                                     region = region,
                                     up_extend = 0,
                                     down_extend = 0,
                                     style = style,
                                     color_by = color_by,
                                     col_pal = col_pal,
                                     allow_truncated = allow_truncated,
                                     curve_width = curve_width,
                                     max_arrow_length = max_arrow_length)
  
  #return
  return(linkage_plot)
}
