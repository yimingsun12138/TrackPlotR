#' Coverage track visualization in the specified genome region
#' 
#' @description
#' Generate coverage track plot in the specified genome region.
#' 
#' @param coverage_table Genome coverage table generated by `load_BigWig`.
#' @param region Genome region used to generate the coverage track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend downstream the region?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param y_lim The numerical y-axis limit for coverage track plot.
#' @param sample_order The sample order when generating the coverage track.
#' @param col_pal A custom palette used to override coloring for samples.
#' 
#' @return A ggplot object.
#' 
#' @export
coverage_vis_region <- function(coverage_table,
                                region,
                                up_extend = 0,
                                down_extend = 0,
                                style = c('style_1'),
                                y_lim = NULL,
                                sample_order = NULL,
                                col_pal = NULL){
  
  #check parameter
  if(base::class(coverage_table) != 'data.frame'){
    base::stop('coverage_table must be a data.frame object!')
  }
  
  if(!base::all(c('seqnames','start','end','score','Sample') %in% base::colnames(coverage_table))){
    base::stop('missing columns in coverage_table!')
  }
  
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  IRanges::start(region) <- IRanges::start(region) - up_extend
  IRanges::end(region) <- IRanges::end(region) + down_extend
  
  #check style
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  #basic plot
  coverage_plot <- coverage_vis_basic(coverage_table = coverage_table,
                                      region = region,
                                      y_lim = y_lim,
                                      sample_order = sample_order,
                                      col_pal = col_pal)
  
  #style
  if(style == 'style_1'){
    coverage_plot <- coverage_plot
  }
  
  #return
  return(coverage_plot)
}

#' Coverage track visualization around specified gene region
#' 
#' @description
#' Generate coverage track plot around specified gene region.
#' 
#' @param coverage_table Genome coverage table generated by `load_BigWig`.
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information. Ensembl GTF file is recommended.
#' @param column_name Which column in gene_anno to be searched for the specified gene name?
#' @param gene The name of the specified gene.
#' @param up_extend How many base pairs to extend upstream the gene?
#' @param down_extend How many base pairs to extend downstream the gene?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param y_lim The numerical y-axis limit for coverage track plot.
#' @param sample_order The sample order when generating the coverage track.
#' @param col_pal A custom palette used to override coloring for samples.
#' 
#' @return A ggplot object.
#' 
#' @export
coverage_vis_gene <- function(coverage_table,
                              gene_anno,
                              column_name,
                              gene,
                              up_extend = 3000,
                              down_extend = 3000,
                              style = c('style_1'),
                              y_lim = NULL,
                              sample_order = NULL,
                              col_pal = NULL){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!base::all(c('type',column_name) %in% base::colnames(gene_anno@elementMetadata))){
    base::stop(base::paste0('gene_anno must contain two columns: type and ',column_name,'!'))
  }
  
  #get gene region
  idx <- base::which((gene_anno$type == 'gene') & (gene_anno@elementMetadata[,column_name] == gene))
  if(base::length(idx) == 0){
    base::stop(base::paste(gene,'not found in the annotation!',sep = ' '))
  }
  if(base::length(idx) > 1){
    base::stop('multiple gene regions detected in the annotation!')
  }
  
  region <- gene_anno[idx]
  if(region@strand == '-'){
    IRanges::start(region) <- IRanges::start(region) - down_extend
    IRanges::end(region) <- IRanges::end(region) + up_extend
  }else{
    IRanges::start(region) <- IRanges::start(region) - up_extend
    IRanges::end(region) <- IRanges::end(region) + down_extend
  }
  
  #plot
  coverage_plot <- coverage_vis_region(coverage_table = coverage_table,
                                       region = region,
                                       up_extend = 0,
                                       down_extend = 0,
                                       style = style,
                                       y_lim = y_lim,
                                       sample_order = sample_order,
                                       col_pal = col_pal)
  
  #return
  return(coverage_plot)
}

#' Feature track visualization in the specified genome region
#' 
#' @description
#' Generate feature track plot in the specified genome region.
#' 
#' @param features A list of bed file paths or a GRanges/GRangesList object which stores the coordinates of genome features.
#' @param region Genome region used to generate the feature track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend downstream the region?
#' @param collapse_features Whether collapse the feature track, default is FALSE.
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param col_pal A custom palette used to override coloring for features.
#' @param overlap_col Color for overlapped region of different features if collapse_features is set to TRUE.
#' @param segment_size The thickness (linewidth) of the feature segment.
#' 
#' @return A ggplot object.
#' 
#' @export
feature_vis_region <- function(features,
                               region,
                               up_extend = 0,
                               down_extend = 0,
                               collapse_features = FALSE,
                               style = c('style_1'),
                               col_pal = NULL,
                               overlap_col = 'darkgrey',
                               segment_size = 2){
  
  #check parameter
  if(base::grepl(pattern = 'GRanges',x = base::class(features),fixed = TRUE)){
    features <- features
  }else{
    features <- base::unlist(features)
    if(base::class(features) == 'character'){
      feature_name <- base::names(features)
      features <- base::do.call(what = GenomicRanges::GRangesList,args = base::lapply(X = features,FUN = rtracklayer::import.bed))
      base::names(features) <- feature_name
    }else{
      base::stop('features must be a list of bed file paths or a GRanges/GRangesList object!')
    }
  }
  
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  IRanges::start(region) <- IRanges::start(region) - up_extend
  IRanges::end(region) <- IRanges::end(region) + down_extend
  
  #check style
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  #basic plot
  feature_plot <- feature_vis_basic(Ranges = features,
                                    region = region,
                                    collapse_range = collapse_features,
                                    col_pal = col_pal,
                                    overlap_col = overlap_col,
                                    segment_size = segment_size)
  
  #style
  if(style == 'style_1'){
    feature_plot <- feature_plot
  }
  
  #return
  return(feature_plot)
}

#' Feature track visualization around specified gene region
#' 
#' @description
#' Generate feature track plot around specified gene region.
#' 
#' @param features A list of bed file paths or a GRanges/GRangesList object which stores the coordinates of genome features.
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information. Ensembl GTF file is recommended.
#' @param column_name Which column in gene_anno to be searched for the specified gene name?
#' @param gene The name of the specified gene.
#' @param up_extend How many base pairs to extend upstream the gene?
#' @param down_extend How many base pairs to extend downstream the gene?
#' @param collapse_features Whether collapse the feature track, default is FALSE.
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param col_pal A custom palette used to override coloring for features.
#' @param overlap_col Color for overlapped region of different features if collapse_features is set to TRUE.
#' @param segment_size The thickness (linewidth) of the feature segment.
#' 
#' @return A ggplot object.
#' 
#' @export
feature_vis_gene <- function(features,
                             gene_anno,
                             column_name,
                             gene,
                             up_extend = 3000,
                             down_extend = 3000,
                             collapse_features = FALSE,
                             style = c('style_1'),
                             col_pal = NULL,
                             overlap_col = 'darkgrey',
                             segment_size = 2){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!base::all(c('type',column_name) %in% base::colnames(gene_anno@elementMetadata))){
    base::stop(base::paste0('gene_anno must contain two columns: type and ',column_name,'!'))
  }
  
  #get gene region
  idx <- base::which((gene_anno$type == 'gene') & (gene_anno@elementMetadata[,column_name] == gene))
  if(base::length(idx) == 0){
    base::stop(base::paste(gene,'not found in the annotation!',sep = ' '))
  }
  if(base::length(idx) > 1){
    base::stop('multiple gene regions detected in the annotation!')
  }
  
  region <- gene_anno[idx]
  if(region@strand == '-'){
    IRanges::start(region) <- IRanges::start(region) - down_extend
    IRanges::end(region) <- IRanges::end(region) + up_extend
  }else{
    IRanges::start(region) <- IRanges::start(region) - up_extend
    IRanges::end(region) <- IRanges::end(region) + down_extend
  }
  
  #plot
  feature_plot <- feature_vis_region(features = features,
                                     region = region,
                                     up_extend = 0,
                                     down_extend = 0,
                                     collapse_features = collapse_features,
                                     style = style,
                                     col_pal = col_pal,
                                     overlap_col = overlap_col,
                                     segment_size = segment_size)
  
  #return
  return(feature_plot)
}

#' Transcript track visualization in the specified genome region
#' 
#' @description
#' Generate transcript track plot in the specified genome region. 
#' This function is the user interface for the basic function `transcript_vis_basic`, 
#' and is specifically optimized for Ensembl GTF file.
#' 
#' @param gene_anno Gene annotation (GTF) file path or a GRanges object which stores the gene annotation information. Ensembl GTF file is recommended.
#' @param region Genome region used to generate the feature track plot, must be a GRanges object.
#' @param up_extend How many base pairs to extend upstream the region?
#' @param down_extend How many base pairs to extend upstream the region?
#' @param style Plot style provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param arrow_break The gap between neighbor arrows equals to region width times arrow_break.
#' @param display_by Display by transcripts or display by genes?
#' @param display_mode Display mode provided by package, check the [document](https://github.com/yimingsun12138/TrackPlotR) for details.
#' @param show_name Which column in gene_anno stores the transcript/gene names to be plotted? Set to NULL and no name will be shown.
#' @param ... Try `?TrackPlotR::transcript_vis_basic` for more parameters.
#' 
#' @return A ggplot object.
#' 
#' @export
transcript_vis_region <- function(gene_anno,
                                  region,
                                  up_extend = 0,
                                  down_extend = 0,
                                  style = c('style_1'),
                                  arrow_break = 0.04,
                                  display_by = c('gene','transcript'),
                                  display_mode = c('squish','full','collapse'),
                                  show_name = NULL,
                                  ...){
  
  #check parameter
  if(base::class(gene_anno) != 'GRanges'){
    gene_anno <- rtracklayer::import(con = gene_anno,format = 'gtf')
  }
  
  if(!('type' %in% base::colnames(gene_anno@elementMetadata))){
    base::stop('gene_anno must contain the column: type!')
  }
  
  if(sum(gene_anno$type == 'transcript') == 0){
    base::stop('no transcript found in gene_anno!')
  }
  idx <- base::which(gene_anno$type %in% c('transcript','exon','CDS'))
  gene_anno <- gene_anno[idx]
  
  style <- style[1]
  if(!(style %in% c('style_1'))){
    base::stop('invalid style!')
  }
  
  display_by <- display_by[1]
  if(!(display_by %in% c('gene','transcript'))){
    base::stop('invalid display_by!')
  }
  
  display_mode <- display_mode[1]
  if(!(display_mode %in% c('squish','full','collapse'))){
    base::stop('invalid display_mode!')
  }
  
  if(!base::is.null(show_name)){
    if(!(show_name %in% base::colnames(gene_anno@elementMetadata))){
      base::stop(base::paste0('gene_anno must contain the column: ',show_name,'!'))
    }
  }
  
  if(base::class(region) != 'GRanges'){
    base::stop('region must be a GRanges object!')
  }else{
    if(base::length(region) != 1){
      base::stop('only 1 region required!')
    }
  }
  
  #extend region
  IRanges::start(region) <- IRanges::start(region) - up_extend
  IRanges::end(region) <- IRanges::end(region) + down_extend
  
  #initialize gene_anno
  if(display_by == 'gene'){
    #check data
    if(!('gene_id' %in% base::colnames(gene_anno@elementMetadata))){
      base::stop('gene_anno must contain the column: gene_id!')
    }
    if(!base::all(!base::is.na(gene_anno$gene_id))){
      base::stop('NA is not allowed in gene_anno column: gene_id!')
    }
    
    #modify
    gene_anno$unique_id <- base::as.character(gene_anno$gene_id)
    
  }else if(display_by == 'transcript'){
    #check data
    if(!('transcript_id' %in% base::colnames(gene_anno@elementMetadata))){
      base::stop('gene_anno must contain the column: transcript_id!')
    }
    if(!base::all(!base::is.na(gene_anno$transcript_id))){
      base::stop('NA is not allowed in gene_anno column: transcript_id!')
    }
    
    #modify
    gene_anno$unique_id <- base::as.character(gene_anno$transcript_id)
    
  }else{
    base::stop('I can not believe this happened, LOL')
  }
  
  if(base::is.null(show_name)){
    gene_anno$unique_name <- NA
  }else{
    gene_anno$unique_name <- base::as.character(gene_anno@elementMetadata[,show_name])
  }
  
  gene_anno$cluster <- 1
  
  #subset gene_anno
  gene_anno <- IRanges::subsetByOverlaps(x = gene_anno,ranges = region)
  
  #modify gene_anno
  if(base::length(gene_anno) != 0){
    #generate gene region if display by gene
    if(display_by == 'gene'){
      gene_list <- base::unique(base::as.character(gene_anno$gene_id))
      gene_list <- base::do.call(what = base::c,args = base::lapply(X = gene_list,FUN = function(x){
        idx <- base::which(gene_anno$gene_id == x)
        temp_anno <- gene_anno[idx]
        
        chr <- base::unique(base::as.character(temp_anno@seqnames))
        start_site <- base::as.character(base::min(IRanges::start(temp_anno)))
        end_site <- base::as.character(base::max(IRanges::end(temp_anno)))
        
        temp_gene_region <- methods::as(object = base::paste0(chr,':',start_site,'-',end_site),Class = 'GRanges')
        temp_gene_region$type <- 'transcript'
        temp_gene_region$unique_id <- base::unique(base::as.character(temp_anno$unique_id))
        temp_name <- base::unique(base::as.character(temp_anno$unique_name))
        if(base::length(temp_name) != 1){
          temp_gene_region$unique_name <- NA
        }else{
          temp_gene_region$unique_name <- temp_name
        }
        
        return(temp_gene_region)
      }))
      
      idx <- base::which(gene_anno$type != 'transcript')
      gene_anno <- c(gene_anno[idx],gene_list)
    }
    
    #group gene_anno
    if(display_mode == 'squish'){
      gene_anno <- group_transcripts(gene_anno = gene_anno,column_name = 'unique_id')
      gene_anno$cluster <- base::max(gene_anno$cluster) - gene_anno$cluster + 1
    }else if(display_mode == 'full'){
      gene_anno$cluster <- gene_anno$unique_id
    }else if(display_mode == 'collapse'){
      gene_anno$cluster <- 1
    }else{
      base::stop('I can not believe this happened, LOL')
    }
  }
  
  #plot
  transcript_plot <- transcript_vis_basic(anno = gene_anno,
                                          region = region,
                                          arrow_break = arrow_break,
                                          show_name = 'unique_name',
                                          ...)
  
  #style
  if(style == 'style_1'){
    transcript_plot <- transcript_plot
  }
  
  #return
  return(transcript_plot)
}
